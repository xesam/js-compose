{"version":3,"file":"index.modern.mjs","sources":["../src/decorate.ts","../src/around.ts","../src/wrap.ts","../src/hook.ts"],"sourcesContent":["export type SrcFunction = Function | null | undefined;\nexport type FunctionDecoration = (srcFunc: SrcFunction, ...args: any[]) => any;\nexport type ThisType = any;\nexport type ThisArg = any;\n\nexport const NAME_SYM = Symbol(\"name\");\n\nexport default function decorate(srcFunc: SrcFunction, decoration: FunctionDecoration, argThis?: ThisArg) {\n    if (typeof decoration !== \"function\") {\n        throw new Error(\"decoration must be function\");\n    }\n    const $ = function (this: ThisType, ...args: any[]) {\n        return decoration.call(argThis || this, srcFunc, ...args);\n    };\n    $[NAME_SYM] = srcFunc?.name;\n    return $;\n}\n\nexport {decorate}","import decorate, {FunctionDecoration, SrcFunction, ThisArg, ThisType} from \"./decorate\";\n\nexport type AroundDecoration = {\n    before?: (...args: any[]) => void;\n    afterReturn?: (result: any, ...args: any[]) => any;\n    afterThrow?: (error: Error, ...args: any[]) => void;\n    after?: (result: any, error: Error | null, ...args: any[]) => void;\n}\n\nfunction _toAdviceDecoration(decoration: AroundDecoration): FunctionDecoration {\n    return function $adviceDecoration(this: ThisType, srcFunc: SrcFunction, ...args: any[]) {\n        if (decoration.before) {\n            decoration.before.apply(this, args);\n        }\n        let finalReturnValue: any;\n        let srcFuncErr: Error | null = null;\n        try {\n            if (srcFunc) {\n                finalReturnValue = srcFunc.apply(this, args);\n            }\n        } catch (e) {\n            srcFuncErr = e as Error;\n            if (decoration.afterThrow) {\n                decoration.afterThrow.apply(this, [srcFuncErr, ...args]); // no need to try-catch\n            } else {\n                throw srcFuncErr;\n            }\n        }\n        if (!srcFuncErr && decoration.afterReturn) {\n            finalReturnValue = decoration.afterReturn.apply(this, [finalReturnValue, ...args]);\n        }\n\n        if (decoration.after) {\n            decoration.after.apply(this, [finalReturnValue, srcFuncErr, ...args]);\n        }\n        return finalReturnValue;\n    };\n}\n\nexport default function around(srcFunc: SrcFunction, decoration: AroundDecoration, argThis?: ThisArg) {\n    const aroundDecoration = _toAdviceDecoration(decoration);\n    return decorate(srcFunc, aroundDecoration, argThis);\n}\n\nexport {around}","import {decorate, FunctionDecoration, SrcFunction, ThisArg} from './decorate';\nimport {around, AroundDecoration} from './around';\n\nexport type WrapDecoration = FunctionDecoration | AroundDecoration;\n\nexport default function _wrap(srcFunc: SrcFunction, decoration: WrapDecoration, argThis?: ThisArg) {\n    if (!decoration || typeof decoration === 'function') {\n        return decorate(srcFunc, decoration, argThis);\n    } else {\n        return around(srcFunc, decoration, argThis);\n    }\n}\n\nexport {_wrap as wrap}","import {wrap, WrapDecoration} from \"./wrap\";\nimport {NAME_SYM, ThisArg} from \"./decorate\";\nimport {AroundDecoration} from \"./around\";\n\nexport type AttrName = string | symbol;\n\nexport type LeafNode = {\n    [key: AttrName]: Function\n}\n\nexport type TreeNode = {\n    [key: AttrName]: undefined | Function | LeafNode | TreeNode\n}\n\nexport type DecorationBuilder = (...args: any[]) => WrapDecoration | false;\n\nexport type AttrDecoration = AroundDecoration | DecorationBuilder;\n\nexport type NamedDecoration = {\n    [name: AttrName]: AttrDecoration;\n}\n\n/**\n * hook_node_attr({}, 'fn', decoration, context)\n * */\nfunction hook_node_attr(node: LeafNode, attr_name: AttrName, decoration: AttrDecoration, argThis?: ThisArg) {\n    if (typeof decoration === 'function') { //a builder\n        const final_decoration = decoration.call(argThis || node, node);\n        if (!final_decoration) {\n            return node;\n        }\n        decoration = final_decoration;\n    }\n    if (decoration) {\n        node[attr_name] = wrap(node[attr_name], decoration, argThis);\n    }\n    return node;\n}\n\n/**\n * hook_node_path('.', root, 'a', decoration, context)\n * hook_node_path('.', root, 'a.b.c.d.e', decoration, context)\n * */\nfunction hook_node_path(sep: string, node: TreeNode, name: AttrName, decoration: AttrDecoration, argThis?: ThisArg) {\n    const str_name = String(name);\n    const sep_index = str_name.indexOf(sep);\n    if (sep_index === -1) {\n        hook_node_attr(node as LeafNode, name, decoration, argThis);\n    } else {\n        const child_attr_name = str_name.substring(0, sep_index);\n        const child_node = node[child_attr_name] || {};\n        node[child_attr_name] = hook_node_path(sep, child_node as TreeNode, str_name.substring(sep_index + 1), decoration, argThis);\n    }\n    return node;\n}\n\n/**\n * hook_node_paths('.', root, ['a','b','c.d','methods.a.b.c.d.e'], decoration, context)\n * */\nfunction hook_node_paths(sep: string, root: TreeNode, names: AttrName[], decoration: AttrDecoration, argThis?: ThisArg) {\n    for (const name of names) {\n        hook_node_path(sep, root, name, decoration, argThis);\n    }\n    return root;\n}\n\n/**\n * hook_named_path('.', root, {\n *  'a':{ before:function(){}, after:function(){}}\n *  'b.c':{ before:function(){}, after:function(){}}\n * }, context)\n * */\nfunction hook_named_path(sep: string, root: TreeNode, named_decoration: NamedDecoration, argThis?: ThisArg) {\n    Object.entries(named_decoration)\n        .forEach(([name, decoration]) => {\n            hook_node_path(sep, root, name, decoration, argThis);\n        });\n    return root;\n}\n\ntype InputArgs =\n    | [root: TreeNode, name: AttrName | AttrName[], decoration: AttrDecoration, argThis?: ThisArg]\n    | [root: TreeNode, name: NamedDecoration, argThis?: ThisArg];\n\nfunction create(sep = '.') {\n    const $ = function (...args: InputArgs) {\n        if (Array.isArray(args[1])) {\n            return hook_node_paths(sep, args[0], args[1], args[2], args[3]);\n        } else if (typeof args[1] === 'string' || typeof args[1] === 'symbol') {\n            return hook_node_path(sep, args[0], args[1], args[2], args[3]);\n        } else {\n            return hook_named_path(sep, args[0], args[1] as NamedDecoration, args[2]);\n        }\n    }\n    Object.defineProperty($, NAME_SYM, {\n        value: `sep-[${sep}]`,\n        enumerable: true,\n        writable: false,\n        configurable: false\n    })\n    return $;\n}\n\nconst _default = create();\n\nexport default _default;\n\nexport {\n    create\n}"],"names":["NAME_SYM","Symbol","decorate","srcFunc","decoration","argThis","Error","$","args","call","this","name","around","aroundDecoration","finalReturnValue","before","apply","srcFuncErr","e","afterThrow","afterReturn","after","_toAdviceDecoration","_wrap","hook_node_path","sep","node","str_name","String","sep_index","indexOf","attr_name","final_decoration","wrap","hook_node_attr","child_attr_name","substring","create","Array","isArray","root","names","hook_node_paths","named_decoration","Object","entries","forEach","hook_named_path","defineProperty","value","enumerable","writable","configurable","_default"],"mappings":"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"}