{"version":3,"file":"index.module.js","sources":["../src/decorate.ts","../src/around.ts","../src/wrap.ts","../src/hook.ts"],"sourcesContent":["export type SrcFunction = Function | null | undefined;\nexport type FunctionDecoration = (srcFunc: SrcFunction, ...args: any[]) => any;\nexport type ThisType = any;\nexport type ThisArg = any;\n\nexport const NAME_SYM = Symbol(\"name\");\n\nexport default function decorate(srcFunc: SrcFunction, decoration: FunctionDecoration, argThis?: ThisArg) {\n    if (typeof decoration !== \"function\") {\n        throw new Error(\"decoration must be function\");\n    }\n    const $ = function (this: ThisType, ...args: any[]) {\n        return decoration.call(argThis || this, srcFunc, ...args);\n    };\n    $[NAME_SYM] = srcFunc?.name;\n    return $;\n}\n\nexport {decorate}","import decorate, {FunctionDecoration, SrcFunction, ThisArg, ThisType} from \"./decorate\";\n\nexport type AroundDecoration = {\n    before?: (...args: any[]) => void;\n    afterReturn?: (result: any, ...args: any[]) => any;\n    afterThrow?: (error: Error, ...args: any[]) => void;\n    after?: (result: any, error: Error | null, ...args: any[]) => void;\n}\n\nfunction _toAdviceDecoration(decoration: AroundDecoration): FunctionDecoration {\n    return function $adviceDecoration(this: ThisType, srcFunc: SrcFunction, ...args: any[]) {\n        if (decoration.before) {\n            decoration.before.apply(this, args);\n        }\n        let finalReturnValue: any;\n        let srcFuncErr: Error | null = null;\n        try {\n            if (srcFunc) {\n                finalReturnValue = srcFunc.apply(this, args);\n            }\n        } catch (e) {\n            srcFuncErr = e as Error;\n            if (decoration.afterThrow) {\n                decoration.afterThrow.apply(this, [srcFuncErr, ...args]); // no need to try-catch\n            } else {\n                throw srcFuncErr;\n            }\n        }\n        if (!srcFuncErr && decoration.afterReturn) {\n            finalReturnValue = decoration.afterReturn.apply(this, [finalReturnValue, ...args]);\n        }\n\n        if (decoration.after) {\n            decoration.after.apply(this, [finalReturnValue, srcFuncErr, ...args]);\n        }\n        return finalReturnValue;\n    };\n}\n\nexport default function around(srcFunc: SrcFunction, decoration: AroundDecoration, argThis?: ThisArg) {\n    const aroundDecoration = _toAdviceDecoration(decoration);\n    return decorate(srcFunc, aroundDecoration, argThis);\n}\n\nexport {around}","import {decorate, FunctionDecoration, SrcFunction, ThisArg} from './decorate';\nimport {around, AroundDecoration} from './around';\n\nexport type WrapDecoration = FunctionDecoration | AroundDecoration;\n\nexport default function _wrap(srcFunc: SrcFunction, decoration: WrapDecoration, argThis?: ThisArg) {\n    if (!decoration || typeof decoration === 'function') {\n        return decorate(srcFunc, decoration, argThis);\n    } else {\n        return around(srcFunc, decoration, argThis);\n    }\n}\n\nexport {_wrap as wrap}","import {wrap, WrapDecoration} from \"./wrap\";\nimport {NAME_SYM, ThisArg} from \"./decorate\";\nimport {AroundDecoration} from \"./around\";\n\nexport type AttrName = string | symbol;\n\nexport type LeafNode = {\n    [key: AttrName]: Function\n}\n\nexport type TreeNode = {\n    [key: AttrName]: undefined | Function | LeafNode | TreeNode\n}\n\nexport type DecorationBuilder = (...args: any[]) => WrapDecoration | false;\n\nexport type AttrDecoration = AroundDecoration | DecorationBuilder;\n\nexport type NamedDecoration = {\n    [name: AttrName]: AttrDecoration;\n}\n\n/**\n * hook_node_attr({}, 'fn', decoration, context)\n * */\nfunction hook_node_attr(node: LeafNode, attr_name: AttrName, decoration: AttrDecoration, argThis?: ThisArg) {\n    if (typeof decoration === 'function') { //a builder\n        const final_decoration = decoration.call(argThis || node, node);\n        if (!final_decoration) {\n            return node;\n        }\n        decoration = final_decoration;\n    }\n    if (decoration) {\n        node[attr_name] = wrap(node[attr_name], decoration, argThis);\n    }\n    return node;\n}\n\n/**\n * hook_node_path('.', root, 'a', decoration, context)\n * hook_node_path('.', root, 'a.b.c.d.e', decoration, context)\n * */\nfunction hook_node_path(sep: string, node: TreeNode, name: AttrName, decoration: AttrDecoration, argThis?: ThisArg) {\n    const str_name = String(name);\n    const sep_index = str_name.indexOf(sep);\n    if (sep_index === -1) {\n        hook_node_attr(node as LeafNode, name, decoration, argThis);\n    } else {\n        const child_attr_name = str_name.substring(0, sep_index);\n        const child_node = node[child_attr_name] || {};\n        node[child_attr_name] = hook_node_path(sep, child_node as TreeNode, str_name.substring(sep_index + 1), decoration, argThis);\n    }\n    return node;\n}\n\n/**\n * hook_node_paths('.', root, ['a','b','c.d','methods.a.b.c.d.e'], decoration, context)\n * */\nfunction hook_node_paths(sep: string, root: TreeNode, names: AttrName[], decoration: AttrDecoration, argThis?: ThisArg) {\n    for (const name of names) {\n        hook_node_path(sep, root, name, decoration, argThis);\n    }\n    return root;\n}\n\n/**\n * hook_named_path('.', root, {\n *  'a':{ before:function(){}, after:function(){}}\n *  'b.c':{ before:function(){}, after:function(){}}\n * }, context)\n * */\nfunction hook_named_path(sep: string, root: TreeNode, named_decoration: NamedDecoration, argThis?: ThisArg) {\n    Object.entries(named_decoration)\n        .forEach(([name, decoration]) => {\n            hook_node_path(sep, root, name, decoration, argThis);\n        });\n    return root;\n}\n\ntype InputArgs =\n    | [root: TreeNode, name: AttrName | AttrName[], decoration: AttrDecoration, argThis?: ThisArg]\n    | [root: TreeNode, name: NamedDecoration, argThis?: ThisArg];\n\nfunction create(sep = '.') {\n    const $ = function (...args: InputArgs) {\n        if (Array.isArray(args[1])) {\n            return hook_node_paths(sep, args[0], args[1], args[2], args[3]);\n        } else if (typeof args[1] === 'string' || typeof args[1] === 'symbol') {\n            return hook_node_path(sep, args[0], args[1], args[2], args[3]);\n        } else {\n            return hook_named_path(sep, args[0], args[1] as NamedDecoration, args[2]);\n        }\n    }\n    Object.defineProperty($, NAME_SYM, {\n        value: `sep-[${sep}]`,\n        enumerable: true,\n        writable: false,\n        configurable: false\n    })\n    return $;\n}\n\nconst _default = create();\n\nexport default _default;\n\nexport {\n    create\n}"],"names":["NAME_SYM","Symbol","decorate","srcFunc","decoration","argThis","Error","$","call","apply","this","concat","slice","arguments","name","around","aroundDecoration","finalReturnValue","args","before","srcFuncErr","e","afterThrow","afterReturn","after","_toAdviceDecoration","_wrap","hook_node_path","sep","node","str_name","String","sep_index","indexOf","attr_name","final_decoration","wrap","hook_node_attr","child_attr_name","substring","create","Array","isArray","root","names","_step","_iterator","_createForOfIteratorHelperLoose","done","value","hook_node_paths","named_decoration","Object","entries","forEach","_ref","hook_named_path","defineProperty","enumerable","writable","configurable","_default"],"mappings":"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"}